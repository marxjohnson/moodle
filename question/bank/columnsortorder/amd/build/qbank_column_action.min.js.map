{"version":3,"file":"qbank_column_action.min.js","sources":["../src/qbank_column_action.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Setting up resize, pin, move, and show/hide actions for the specified table\n * Columns on the same header should have same data id attribute as to identify if a column belong to a header.\n *\n *\n * @module     qbank_columnsortorder/qbank_column_action\n * @copyright  2022 Catalyst IT Australia Pty Ltd\n * @author     Nathan Nguyen <nathannguyen@catalyst-ca.net>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport {exception as displayException} from 'core/notification';\nimport {get_string as getString} from 'core/str';\nimport * as repository from 'qbank_columnsortorder/repository';\nimport jQuery from 'jquery';\nimport ModalEvents from 'core/modal_events';\nimport ModalFactory from 'core/modal_factory';\nimport Notification from 'core/notification';\nimport Templates from 'core/templates';\nimport SortableList from 'core/sortable_list';\n\n/** The table that we will add action */\nlet table;\n\n/** Data attribute used to identify each colum */\nlet dataIdAttribute;\n\n/** Data attribute used to display name of a column */\nlet dataNameAttribute;\n\n/** To track mouse event on a table header */\nlet currentHeader;\n\n/** To track current pinned header */\nlet currentPinnedHeader;\n\n/** Current mouse x postion, to track mouse event on a table header */\nlet currentX;\n\nconst SELECTORS = {\n    MOVE_HANDLE: '[data-action=\"move\"]',\n    RESIZE_HANDLE: '[data-action=\"resize\"]',\n    PIN_HANDLE: '[data-action=\"pin\"]',\n    PINNED_CLASS: 'pinned',\n    tableHeader: identifier => `th[data-${dataIdAttribute}=\"${identifier.replace(/[\"\\\\]/g, '\\\\$&')}\"]`,\n    tableColumn: identifier => `td[data-${dataIdAttribute}=\"${identifier.replace(/[\"\\\\]/g, '\\\\$&')}\"]`,\n    tableHeaderSection: tableid => `#${tableid} thead tr`,\n};\n\n/**\n * Add handle\n * @param {Object} context data for each handle.\n * @param {Element} container container cthat will hold a action icon\n * @returns {Promise}\n */\nconst addHandle = (context, container) => {\n    return Templates.renderForPromise('qbank_columnsortorder/action_handle', context)\n        .then(({html, js}) => {\n            Templates.appendNodeContents(container, html, js);\n            return container;\n        });\n};\n\n/**\n * Gets the newly reordered columns to display in the question bank view.\n * @returns {Array}\n */\nconst getColumnOrder = () => {\n    const tableHeaders = table.querySelectorAll(\"th\");\n    const columns = Array.from(tableHeaders).map(column => column.dataset[dataIdAttribute]);\n    return columns.filter((value, index) => columns.indexOf(value) === index);\n};\n\n/**\n * Set up move handle\n * @param {String} handleContainer container class that will hold the move icon.\n * @param {String} component The component to save preferences against.\n */\nconst setUpMoveHandle = (handleContainer, component = '') => {\n    // Add \"move icon\" for each header.\n    const tableHeaders = table.querySelectorAll(\"th:not(.checkbox)\");\n    tableHeaders.forEach(async(header) => {\n        const context = {\n            action: \"move\",\n            target: header.dataset[dataIdAttribute],\n            title: await getString('movecolumn', 'qbank_columnsortorder', header.dataset[dataNameAttribute]),\n            pixicon: \"i/dragdrop\",\n            pixcomponent: \"core\",\n            popup: true\n        };\n        const container = header.querySelector(handleContainer);\n        addHandle(context, container).catch(ex => displayException(ex));\n    });\n\n    const headerSectionSelector = SELECTORS.tableHeaderSection(table.id);\n    const headerSection = jQuery(headerSectionSelector);\n\n    // Implement drag and drop.\n    new SortableList(headerSectionSelector, {\n        moveHandlerSelector: SELECTORS.MOVE_HANDLE,\n        isHorizontal: true\n    });\n\n    headerSection.on(SortableList.EVENTS.DRAGSTART, event => {\n        if (event.target.classList.contains('header')) {\n            event.target.classList.add('active');\n        }\n    });\n\n    headerSection.on(SortableList.EVENTS.DRAGEND, event => {\n        if (event.target.classList.contains('active')) {\n            event.target.classList.remove('active');\n        }\n    });\n\n    headerSection.on(SortableList.EVENTS.DROP, event => {\n        // Current header.\n        const header = event.target;\n        // Find the previous sibling of the header, which will be used when moving columns.\n        const insertAfter = header.previousElementSibling;\n\n        // Move columns.\n        const columns = table.querySelectorAll(SELECTORS.tableColumn(header.dataset[dataIdAttribute]));\n        columns.forEach(column => {\n            const row = column.parentElement;\n            if (insertAfter) {\n                // Find the column to insert after.\n                const insertAfterColumn = row.querySelector(SELECTORS.tableColumn(insertAfter.dataset[dataIdAttribute]));\n                // Insert the column.\n                insertAfterColumn.after(column);\n            } else {\n                // Insert as the first child (first column in the table).\n                row.insertBefore(column, row.firstChild);\n            }\n        });\n\n        // Persist column order.\n        repository.setColumnbankOrder(getColumnOrder(), component).catch(Notification.exception);\n\n        // Update pinned headers.\n        rePinHeaders();\n    });\n\n};\n\n/**\n * Pin an element\n * @param {Element} element the node that will be pinned\n * @param {Number} width the width of pinned node.\n * @param {Number} zIndex so that the pinned node will be laid above other element.\n * @param {Number} left distance to the left border of the table.\n */\nconst pinElement = (element, width, zIndex, left) => {\n    element.style.width = width + \"px\";\n    element.style.zIndex = zIndex;\n    element.style.left = left + \"px\";\n    element.classList.add('pinned');\n};\n\n/**\n * Unpin an element\n * @param {Element} element the node that will be unpinned\n */\nconst unpinElement = (element) => {\n    element.style.zIndex = \"\";\n    element.style.left = \"\";\n    element.classList.remove('pinned');\n};\n\n/**\n * Process pinned elements\n * @param {bool} toBePinned to be pinned or unpinned\n * @param {Element} stopAtHeader stop pinning after the header\n * @returns {Array} list of pinned headers\n */\nconst processPinnedHeaders = (toBePinned, stopAtHeader) => {\n    let left = 0;\n    let pinnedHeaders = [];\n    const tableHeaders = table.querySelectorAll(\"thead th\");\n    // Each header should be higher than the next header along, so that the resize icons overlap correctly.\n    let headerZIndex = Array.from(tableHeaders).findIndex(header => header === stopAtHeader) + 1;\n\n    // Unpin all headers.\n    tableHeaders.forEach((header) => {\n        // Unpin header.\n        unpinElement(header);\n        const button = header.querySelector('.pin-handle span');\n        getString('pincolumn', 'qbank_columnsortorder', header.dataset[dataNameAttribute]).then(str => {\n            button.title = str;\n            return str;\n        }).catch();\n        // Unpin columns.\n        const columns = table.querySelectorAll(SELECTORS.tableColumn(header.dataset[dataIdAttribute]));\n        columns.forEach(column => {\n            unpinElement(column);\n        });\n    });\n\n    // Pin headers.\n    if (toBePinned) {\n        const tableHeadersArr = Array.prototype.slice.call(tableHeaders);\n        tableHeadersArr.some((header) => {\n\n            const width = header.offsetWidth;\n            // Pin header.\n            pinnedHeaders.push(header.dataset[dataIdAttribute]);\n            pinElement(header, width, headerZIndex, left);\n\n            // Pin columns.\n            const columns = table.querySelectorAll(SELECTORS.tableColumn(header.dataset[dataIdAttribute]));\n            // Each row should be higher than the next row down, so action menus overlap correctly.\n            let columnZIndex = columns.length;\n            columns.forEach(column => {\n                pinElement(column, width, columnZIndex, left);\n                columnZIndex--;\n            });\n\n            // Update z-indexes for the next column.\n            headerZIndex -= 1;\n            // Increase margin.\n            left += width;\n\n            // End sticky headers.\n            if (header === stopAtHeader) {\n                const button = header.querySelector('.pin-handle span');\n                getString('unpincolumn', 'qbank_columnsortorder', header.dataset[dataNameAttribute]).then(str => {\n                    button.title = str;\n                    return str;\n                }).catch();\n                return true;\n            }\n            return false;\n        });\n\n    }\n    // Return pinned headers.\n    return pinnedHeaders;\n};\n\n/**\n * Handle activation events on the pin handle.\n *\n * @param {Element} pinHandle The handle that was activated.\n * @returns {Array} list of pinned headers\n */\nconst pinHandler = (pinHandle) => {\n    // Pin all headers to the clicked header.\n    const target = pinHandle.dataset.target;\n    const stopAtHeader = table.querySelector(SELECTORS.tableHeader(target));\n    let toBePinned = true;\n    if (currentPinnedHeader === stopAtHeader.dataset[dataIdAttribute]) {\n        // Unpinned all headers.\n        toBePinned = false;\n        currentPinnedHeader = '';\n    } else {\n        // Track current pinned header.\n        currentPinnedHeader = stopAtHeader.dataset[dataIdAttribute];\n    }\n\n    return processPinnedHeaders(toBePinned, stopAtHeader);\n};\n\n/**\n * Set up pin handle\n * @param {String} handleContainer container class that will hold the pin icon.\n * @param {String} component The component to save preferences against\n */\nconst setUpPinHandle = (handleContainer, component = '') => {\n    // Add \"pin icon\" for each header.\n    const tableHeaders = table.querySelectorAll(\"th:not(.checkbox)\");\n    tableHeaders.forEach(async(header) => {\n        const context = {\n            action: \"pin\",\n            target: header.dataset[dataIdAttribute],\n            title: await getString('pincolumn', 'qbank_columnsortorder', header.dataset[dataNameAttribute]),\n            icon: 'thumb-tack'\n        };\n        const container = header.querySelector(handleContainer);\n        addHandle(context, container);\n    });\n\n    // Mouse event on headers.\n    table.addEventListener('click', e => {\n        const pinHandle = e.target.closest(SELECTORS.PIN_HANDLE);\n        // Return if it is not ' pin' button.\n        if (!pinHandle) {\n            return;\n        }\n        repository.setPinnedColumns(pinHandler(pinHandle), component).catch(Notification.exception);\n    });\n    table.addEventListener('keypress', e => {\n        if (e.key !== 'Enter' && e.key !== ' ') {\n            return;\n        }\n        const pinHandle = e.target.closest(SELECTORS.PIN_HANDLE);\n        // Return if it is not ' pin' button.\n        if (!pinHandle) {\n            return;\n        }\n        e.preventDefault();\n        e.stopPropagation();\n        repository.setPinnedColumns(pinHandler(pinHandle), component).catch(Notification.exception);\n    });\n};\n\n/**\n * Re-pin the headers based on the currently pinned header.\n *\n * This should be called if anything to do with the currently pinned headers changes, such as order\n * or size, so that they are re-calculated correctly.\n */\nconst rePinHeaders = () => {\n    if (currentPinnedHeader) {\n        processPinnedHeaders(true, document.querySelector(SELECTORS.tableHeader(currentPinnedHeader)));\n    }\n};\n\n/**\n * Get the size of each header.\n *\n * @return {Array}\n */\nconst saveColumnSizes = () => {\n    let columnSizes = [];\n    const tableHeaders = table.querySelectorAll(\"th\");\n    tableHeaders.forEach(header => {\n        // Only get the width set via style attribute (set by pin or move action).\n        let size = {\n            column: header.dataset[dataIdAttribute],\n            width: header.style.width\n        };\n        columnSizes.push(size);\n    });\n    return JSON.stringify(columnSizes);\n};\n\n/**\n * Show a modal containing a number input for changing a column width without click-and-drag.\n *\n * @param {Element} currentHeader The header element that is being resized.\n * @param {String} component The component to save preferences against.\n * @returns {Promise<void>}\n */\nconst showResizeModal = async(currentHeader, component = '') => {\n\n    const initialWidth = currentHeader.offsetWidth;\n\n    const modal = await ModalFactory.create({\n        title: getString('resizecolumn', 'qbank_columnsortorder', currentHeader.textContent),\n        type: ModalFactory.types.SAVE_CANCEL,\n        body: Templates.render('qbank_columnsortorder/resize_modal', {})\n    });\n    const root = modal.getRoot();\n    root.on(ModalEvents.cancel, () => {\n        currentHeader.style.width = initialWidth + 'px';\n    });\n    root.on(ModalEvents.save, () => {\n        repository.setColumnSize(saveColumnSizes(), component).catch(Notification.exception);\n        if (currentHeader.classList.contains('pinned')) {\n            rePinHeaders();\n        }\n    });\n    modal.show();\n\n    const body = await modal.bodyPromise;\n    const input = body.get(0).querySelector('input');\n    input.value = initialWidth;\n\n    input.addEventListener('change', e => {\n        const newWidth = e.target.value;\n        currentHeader.style.width = newWidth + 'px';\n    });\n};\n\n/**\n * Set up resize handle\n * @param {String} handleContainer container class that will hold the move icon.\n * @param {String} component The component to save preferences against.\n */\nconst setUpResizeHandle = (handleContainer, component) => {\n    // Add \"move icon\" for each header.\n    const tableHeaders = table.querySelectorAll(\"th:not(.checkbox)\");\n    tableHeaders.forEach(async(header) => {\n        const context = {\n            action: \"resize\",\n            target: header.dataset[dataIdAttribute],\n            title: await getString('resizecolumn', 'qbank_columnsortorder', header.dataset[dataNameAttribute]),\n            pixicon: 'resizehandle',\n            pixcomponent: 'qbank_columnsortorder',\n            popup: true\n        };\n        const container = header.querySelector(handleContainer);\n        addHandle(context, container);\n    });\n\n    let moveTracker = false;\n    let currentResizeHandle = null;\n    // Start mouse event on headers.\n    table.addEventListener('mousedown', e => {\n        currentResizeHandle = e.target.closest(SELECTORS.RESIZE_HANDLE);\n        // Return if it is not ' resize' button.\n        if (!currentResizeHandle) {\n            return;\n        }\n        // Save current position.\n        currentX = e.pageX;\n        // Find the header.\n        const target = currentResizeHandle.dataset.target;\n        currentHeader = table.querySelector(SELECTORS.tableHeader(target));\n        moveTracker = false;\n    });\n\n    // Resize column as the mouse move.\n    document.addEventListener('mousemove', e => {\n        if (!currentHeader || !currentResizeHandle || currentX === 0) {\n            return;\n        }\n\n        document.getSelection().removeAllRanges();\n\n        // Offset.\n        const offset = e.pageX - currentX;\n        currentX = e.pageX;\n        const newWidth = currentHeader.offsetWidth + offset;\n        currentHeader.style.width = newWidth + 'px';\n        moveTracker = true;\n    });\n\n    // Set new size when mouse is up.\n    document.addEventListener('mouseup', () => {\n        if (!currentHeader || !currentResizeHandle || currentX === 0) {\n            return;\n        }\n        if (moveTracker) {\n            // If the mouse moved, we are changing the size by drag, so save the change.\n            repository.setColumnSize(saveColumnSizes(), component).catch(Notification.exception);\n            if (currentHeader.classList.contains('pinned')) {\n                rePinHeaders();\n            }\n        } else {\n            // If the mouse didn't move, display a modal to change the size using a form.\n            showResizeModal(currentHeader, component);\n        }\n        currentHeader = null;\n        currentResizeHandle = null;\n        currentX = 0;\n        moveTracker = false;\n    });\n\n    table.addEventListener('keypress', e => {\n        if (e.key !== 'Enter' && e.key !== ' ') {\n            return;\n        }\n        const resizeHandle = e.target.closest(SELECTORS.RESIZE_HANDLE);\n        // Return if it is not 'resize' button.\n        if (!resizeHandle) {\n            return;\n        }\n        e.preventDefault();\n        e.stopPropagation();\n        const target = resizeHandle.dataset.target;\n        const currentHeader = table.querySelector(SELECTORS.tableHeader(target));\n        showResizeModal(currentHeader, component);\n    });\n};\n\n/**\n * Set up hide/show dropdown\n * @param {String} dropdownContainer container class that will hold the hide/show dropdown.\n * @param {String} component The component to save preferences against.\n */\nconst setUpHideShowDropdown = async(dropdownContainer, component = '') => {\n    const container = document.querySelector(dropdownContainer);\n    let currentHiddenColumns = table.dataset.hiddencolumns;\n    if (currentHiddenColumns) {\n        currentHiddenColumns = JSON.parse(currentHiddenColumns);\n    }\n    let context = {\n        columns: [],\n        text: await getString('showhidecolumn', 'qbank_columnsortorder'),\n        id: \"showhidecolumn\"\n    };\n    const tableHeaders = table.querySelectorAll(\"th:not(.checkbox)\");\n    tableHeaders.forEach(header => {\n        const visible = !currentHiddenColumns || !currentHiddenColumns.includes(header.dataset[dataIdAttribute]);\n        // Data for checkbox.\n        const column = {\n            id: header.dataset[dataIdAttribute],\n            name: header.dataset[dataNameAttribute],\n            checked: visible\n        };\n        context.columns.push(column);\n    });\n\n    return Templates.renderForPromise('qbank_columnsortorder/showhide_dropdown', context)\n        .then(({html, js}) => {\n            Templates.appendNodeContents(container, html, js);\n            addDropdownEventListeners(container, component);\n            return container;\n        });\n};\n\nconst toggleColumnHandler = (checkbox, container, component = '') => {\n    const target = checkbox.value;\n    const header = table.querySelector(SELECTORS.tableHeader(target));\n    if (checkbox.checked === true) {\n        // Show header.\n        header.style.display = \"\";\n        // Show column.\n        const columns = table.querySelectorAll(SELECTORS.tableColumn(target));\n        columns.forEach(column => {\n            column.style.display = \"\";\n        });\n    } else {\n        // Hide header.\n        header.style.display = \"none\";\n        // Hide column.\n        const columns = table.querySelectorAll(SELECTORS.tableColumn(target));\n        columns.forEach(column => {\n            column.style.display = \"none\";\n        });\n    }\n\n    const checkboxes = container.querySelectorAll('input[type=checkbox]');\n    const hiddenColumns = [...checkboxes].filter(checkbox => !checkbox.checked).map(checkbox => checkbox.value);\n    repository.setHiddenColumns(hiddenColumns, component).catch(Notification.exception);\n};\n\n/**\n * Add event listener for drop down item\n * @param {Element} container dropdown container.\n * @param {String} component The component to save preferences against.\n */\nconst addDropdownEventListeners = (container, component = '') => {\n    // Click event when click on an item.\n    container.addEventListener('click', event => {\n        const item = event.target.closest('.dropdown-item');\n        if (!item) {\n            return;\n        }\n        toggleColumnHandler(item.querySelector('input[type=checkbox]'), container, component);\n    });\n    // Keypress inside the list.\n    container.addEventListener('keydown', event => {\n        const item = event.target.closest('.dropdown-item');\n        if (event.key === 'Enter') {\n            // Toggle current item.\n            if (!item) {\n                return;\n            }\n            const checkbox = item.querySelector('input[type=checkbox]');\n            checkbox.checked = !checkbox.checked;\n            toggleColumnHandler(checkbox, container, component);\n        } else if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {\n            // Up or down - move up and down the list.\n            const item = event.target.closest('.dropdown-item');\n            let target = event.currentTarget.querySelector('.dropdown-item:first-of-type');\n            if (item) {\n                if (event.key === 'ArrowUp') {\n                    target = item.previousElementSibling ?? event.currentTarget.querySelector('.dropdown-item:last-of-type');\n                } else {\n                    target = item.nextElementSibling ?? event.currentTarget.querySelector('.dropdown-item:first-of-type');\n                }\n            }\n            target.querySelector('input[type=checkbox]').focus();\n            event.preventDefault();\n        } else {\n            // Ignore all other keys.\n            return;\n        }\n    });\n};\n\n/**\n * Current hidden columns\n */\nconst setUpCurrentHiddenColumns = () => {\n    let currentHiddenColumns = table.dataset.hiddencolumns;\n    if (currentHiddenColumns) {\n        currentHiddenColumns = JSON.parse(currentHiddenColumns);\n    }\n    if (currentHiddenColumns.length > 0) {\n        currentHiddenColumns.forEach(pluginname => {\n            if (!pluginname) {\n                return;\n            }\n            const header = table.querySelector(SELECTORS.tableHeader(pluginname));\n            header.style.display = \"none\";\n            const cells = table.querySelectorAll(SELECTORS.tableColumn(pluginname));\n            cells.forEach(cell => {\n                cell.style.display = \"none\";\n            });\n        });\n    }\n};\n\n/**\n * Current pinned columns\n */\nconst setUpCurrentPinnedColumns = () => {\n    const currentPinnedColumns = table.dataset.pinnedcolumns;\n    if (!currentPinnedColumns) {\n        return;\n    }\n    // Existing pinned headers.\n    const decodedPinnedColumns = JSON.parse(currentPinnedColumns);\n    if (decodedPinnedColumns.length > 0) {\n        // Save pinned header.\n        currentPinnedHeader = decodedPinnedColumns[decodedPinnedColumns.length - 1];\n        if (currentPinnedHeader !== '') {\n            const stopAtHeader = table.querySelector(SELECTORS.tableHeader(currentPinnedHeader));\n            processPinnedHeaders(true, stopAtHeader);\n        }\n    }\n};\n\n/**\n * Set up initial column sizes.\n *\n * If there is a saved column size for the column, use that. Otherwise, set it to the current width of the column on screen.\n */\nconst setUpCurrentColumnSizes = () => {\n    const currentColumnSizes = table.dataset.colsize;\n    let decodedSizes = [];\n    if (currentColumnSizes) {\n        decodedSizes = JSON.parse(currentColumnSizes);\n        if (!Array.isArray(decodedSizes)) {\n            decodedSizes = [];\n        }\n    }\n    const headers = table.querySelectorAll('th');\n    headers.forEach(header => {\n        const colSize = decodedSizes.find(colSize => colSize.column === header.dataset.pluginname);\n        if (colSize && colSize.width !== '') {\n            header.style.width = colSize.width;\n        } else {\n            header.style.width = header.offsetWidth + 'px';\n        }\n    });\n    // Set the width of the table to min-content, so that it can grow beyond the page width, and cells can shrink below their\n    // content width.\n    table.style.width = 'min-content';\n};\n\n/**\n * Initialize module\n *\n * @param {String} id unique id for columns.\n * @return {Boolean} True if the table was set up, false if it was already set up.\n */\nconst setUpTable = (id) => {\n    table = document.getElementById(id);\n\n    // Check if the table is already setup.\n    if (table.dataset.setup == 'true') {\n        return false;\n    }\n\n    dataIdAttribute = 'pluginname';\n    dataNameAttribute = 'name';\n\n    // Add class to each column as to identify them later.\n    const tableHeaders = table.querySelectorAll(\"th\");\n    const rows = table.querySelectorAll(\"tr\");\n    rows.forEach(row => {\n        const columns = row.querySelectorAll(\"td\");\n        for (let i = 0; i < columns.length; i++) {\n            columns[i].dataset[dataIdAttribute] = tableHeaders[i].dataset[dataIdAttribute];\n        }\n    });\n\n    // Prevent from setting up the table again.\n    table.dataset.setup = 'true';\n    return true;\n};\n\n/**\n * Initialise module.\n *\n * Set up the table based on the current settings, and add controls to each column header if\n * editing is enabled.\n *\n * @param {String} tableId ID of the question bank table\n * @param {Boolean} isEditing Should we show the move, resize and pin controls?\n * @param {String} component Component to save user preferences to (empty will save changes to admin settings)\n */\nexport const init = (tableId, isEditing, component = '') => {\n    if (!setUpTable(tableId)) {\n        // Table has already been set up, nothing more to do.\n        return;\n    }\n\n    setUpCurrentHiddenColumns();\n    setUpCurrentColumnSizes();\n    setUpCurrentPinnedColumns();\n\n    if (isEditing) {\n        setUpHideShowDropdown(\"#show-hide-dropdown\", component).catch(Notification.exception);\n        setUpMoveHandle(\".move-handle\", component);\n        setUpPinHandle(\".pin-handle\", component);\n        setUpResizeHandle(\".resize-handle\", component);\n    }\n};\n"],"names":["table","dataIdAttribute","dataNameAttribute","currentHeader","currentPinnedHeader","currentX","SELECTORS","identifier","replace","tableid","addHandle","context","container","Templates","renderForPromise","then","_ref","html","js","appendNodeContents","getColumnOrder","tableHeaders","querySelectorAll","columns","Array","from","map","column","dataset","filter","value","index","indexOf","setUpMoveHandle","handleContainer","component","forEach","async","action","target","header","title","pixicon","pixcomponent","popup","querySelector","catch","ex","headerSectionSelector","id","headerSection","SortableList","moveHandlerSelector","isHorizontal","on","EVENTS","DRAGSTART","event","classList","contains","add","DRAGEND","remove","DROP","insertAfter","previousElementSibling","row","parentElement","after","insertBefore","firstChild","repository","setColumnbankOrder","Notification","exception","rePinHeaders","pinElement","element","width","zIndex","left","style","unpinElement","processPinnedHeaders","toBePinned","stopAtHeader","pinnedHeaders","headerZIndex","findIndex","button","str","prototype","slice","call","some","offsetWidth","push","columnZIndex","length","pinHandler","pinHandle","setUpPinHandle","icon","addEventListener","e","closest","setPinnedColumns","key","preventDefault","stopPropagation","document","saveColumnSizes","columnSizes","size","JSON","stringify","showResizeModal","initialWidth","modal","ModalFactory","create","textContent","type","types","SAVE_CANCEL","body","render","root","getRoot","ModalEvents","cancel","save","setColumnSize","show","bodyPromise","input","get","newWidth","setUpResizeHandle","moveTracker","currentResizeHandle","pageX","getSelection","removeAllRanges","offset","resizeHandle","setUpHideShowDropdown","dropdownContainer","currentHiddenColumns","hiddencolumns","parse","text","visible","includes","name","checked","_ref2","addDropdownEventListeners","toggleColumnHandler","checkbox","display","checkboxes","hiddenColumns","setHiddenColumns","item","currentTarget","nextElementSibling","focus","setUpCurrentHiddenColumns","pluginname","cell","setUpCurrentPinnedColumns","currentPinnedColumns","pinnedcolumns","decodedPinnedColumns","setUpCurrentColumnSizes","currentColumnSizes","colsize","decodedSizes","isArray","colSize","find","setUpTable","getElementById","setup","i","tableId","isEditing"],"mappings":"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"}
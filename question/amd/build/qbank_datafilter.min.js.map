{"version":3,"file":"qbank_datafilter.min.js","sources":["../src/qbank_datafilter.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Question bank filter management.\n *\n * @module     core_question/qbank_datafilter\n * @copyright  2022 Safat Shahin <safatshahin@catalyst-au.net>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport CoreFilter from 'core/datafilter';\nimport Notification from 'core/notification';\nimport Pending from 'core/pending';\nimport Selectors from 'core/datafilter/selectors';\nimport Templates from 'core/templates';\nimport GenericFilter from 'core/datafilter/filtertype';\n\nexport default class extends CoreFilter {\n    constructor(filterSet, applyCallback) {\n        super(filterSet, applyCallback);\n    }\n\n    addFilterRow(filterdata = {}) {\n        const pendingPromise = new Pending('core/datafilter:addFilterRow');\n        const rownum = filterdata.rownum ?? 1 + this.getFilterRegion().querySelectorAll(Selectors.filter.region).length;\n        return Templates.renderForPromise('core_question/qbank_filter_row', {\"rownumber\": rownum})\n            .then(({html, js}) => {\n                const newContentNodes = Templates.appendNodeContents(this.getFilterRegion(), html, js);\n\n                return newContentNodes;\n            })\n            .then(filterRow => {\n                // Note: This is a nasty hack.\n                // We should try to find a better way of doing this.\n                // We do not have the list of types in a readily consumable format, so we take the pre-rendered one and copy\n                // it in place.\n                const typeList = this.filterSet.querySelector(Selectors.data.typeList);\n\n                filterRow.forEach(contentNode => {\n                    const contentTypeList = contentNode.querySelector(Selectors.filter.fields.type);\n\n                    if (contentTypeList) {\n                        contentTypeList.innerHTML = typeList.innerHTML;\n                    }\n                });\n\n                return filterRow;\n            })\n            .then(filterRow => {\n                this.updateFiltersOptions();\n\n                return filterRow;\n            })\n            .then(result => {\n                pendingPromise.resolve();\n\n                if (Object.keys(filterdata).length !== 0) {\n                    result.forEach(filter => {\n                        this.addFilter(filter, filterdata.filtertype, filterdata.values,\n                            filterdata.jointype, filterdata.filteroptions);\n                    });\n                }\n                return result;\n            })\n            .catch(Notification.exception);\n    }\n\n    async addFilter(filterRow, filterType, initialFilterValues, filterJoin, filterOptions) {\n        // Name the filter on the filter row.\n        filterRow.dataset.filterType = filterType;\n\n        const filterDataNode = this.getFilterDataSource(filterType);\n\n        // Instantiate the Filter class.\n        let Filter = GenericFilter;\n        if (filterDataNode.dataset.filterTypeClass) {\n            Filter = await import(filterDataNode.dataset.filterTypeClass);\n        }\n        this.activeFilters[filterType] = new Filter(filterType, this.filterSet, initialFilterValues, filterOptions);\n        // Disable the select.\n        const typeField = filterRow.querySelector(Selectors.filter.fields.type);\n        typeField.value = filterType;\n        typeField.disabled = 'disabled';\n        // Update the join list.\n        this.updateJoinList(filterDataNode.dataset.joinList, filterRow);\n        const joinField = filterRow.querySelector(Selectors.filter.fields.join);\n        joinField.disabled = false;\n        if (isNaN(filterJoin) === false) {\n            joinField.value = filterJoin;\n        }\n        // Update the list of available filter types.\n        this.updateFiltersOptions();\n\n        return this.activeFilters[filterType];\n    }\n\n    updateJoinList(filterJoinData, filterRow) {\n        const regularJoinList = [0, 1, 2];\n        const filterJoinList = JSON.parse(filterJoinData);\n        // Re-construct join type and list.\n        if (filterJoinList.length !== 0) {\n            const joinField = filterRow.querySelector(Selectors.filter.fields.join);\n            regularJoinList.forEach((join) => {\n                if (!filterJoinList.includes(join)) {\n                    joinField.options[join].classList.add('hidden');\n                    joinField.options[join].disabled = true;\n                }\n            });\n            joinField.options.forEach((element, index) => {\n                if (element.disabled) {\n                    joinField.options[index] = null;\n                }\n            });\n            if (joinField.options.length === 1) {\n                joinField.hidden = true;\n            }\n        }\n    }\n}\n"],"names":["CoreFilter","constructor","filterSet","applyCallback","addFilterRow","filterdata","pendingPromise","Pending","rownum","this","getFilterRegion","querySelectorAll","Selectors","filter","region","length","Templates","renderForPromise","then","_ref","html","js","appendNodeContents","filterRow","typeList","querySelector","data","forEach","contentNode","contentTypeList","fields","type","innerHTML","updateFiltersOptions","result","resolve","Object","keys","addFilter","filtertype","values","jointype","filteroptions","catch","Notification","exception","filterType","initialFilterValues","filterJoin","filterOptions","dataset","filterDataNode","getFilterDataSource","Filter","GenericFilter","filterTypeClass","activeFilters","typeField","value","disabled","updateJoinList","joinList","joinField","join","isNaN","filterJoinData","regularJoinList","filterJoinList","JSON","parse","includes","options","classList","add","element","index","hidden"],"mappings":"i3BA8B6BA,oBACzBC,YAAYC,UAAWC,qBACbD,UAAWC,eAGrBC,0CAAaC,kEAAa,SAChBC,eAAiB,IAAIC,iBAAQ,gCAC7BC,kCAASH,WAAWG,wDAAU,EAAIC,KAAKC,kBAAkBC,iBAAiBC,mBAAUC,OAAOC,QAAQC,cAClGC,mBAAUC,iBAAiB,iCAAkC,WAAcT,SAC7EU,MAAKC,WAACC,KAACA,KAADC,GAAOA,gBACcL,mBAAUM,mBAAmBb,KAAKC,kBAAmBU,KAAMC,OAItFH,MAAKK,kBAKIC,SAAWf,KAAKP,UAAUuB,cAAcb,mBAAUc,KAAKF,iBAE7DD,UAAUI,SAAQC,oBACRC,gBAAkBD,YAAYH,cAAcb,mBAAUC,OAAOiB,OAAOC,MAEtEF,kBACAA,gBAAgBG,UAAYR,SAASQ,cAItCT,aAEVL,MAAKK,iBACGU,uBAEEV,aAEVL,MAAKgB,SACF5B,eAAe6B,UAEwB,IAAnCC,OAAOC,KAAKhC,YAAYU,QACxBmB,OAAOP,SAAQd,cACNyB,UAAUzB,OAAQR,WAAWkC,WAAYlC,WAAWmC,OACrDnC,WAAWoC,SAAUpC,WAAWqC,kBAGrCR,UAEVS,MAAMC,sBAAaC,2BAGZtB,UAAWuB,WAAYC,oBAAqBC,WAAYC,eAEpE1B,UAAU2B,QAAQJ,WAAaA,iBAEzBK,eAAiB1C,KAAK2C,oBAAoBN,gBAG5CO,OAASC,oBACTH,eAAeD,QAAQK,kBACvBF,6NAAsBF,eAAeD,QAAQK,2SAAvBJ,eAAeD,QAA5B,2EAAaC,eAAeD,QAAQK,yBAE5CC,cAAcV,YAAc,IAAIO,OAAOP,WAAYrC,KAAKP,UAAW6C,oBAAqBE,qBAEvFQ,UAAYlC,UAAUE,cAAcb,mBAAUC,OAAOiB,OAAOC,MAClE0B,UAAUC,MAAQZ,WAClBW,UAAUE,SAAW,gBAEhBC,eAAeT,eAAeD,QAAQW,SAAUtC,iBAC/CuC,UAAYvC,UAAUE,cAAcb,mBAAUC,OAAOiB,OAAOiC,aAClED,UAAUH,UAAW,GACK,IAAtBK,MAAMhB,cACNc,UAAUJ,MAAQV,iBAGjBf,uBAEExB,KAAK+C,cAAcV,YAG9Bc,eAAeK,eAAgB1C,iBACrB2C,gBAAkB,CAAC,EAAG,EAAG,GACzBC,eAAiBC,KAAKC,MAAMJ,mBAEJ,IAA1BE,eAAepD,OAAc,OACvB+C,UAAYvC,UAAUE,cAAcb,mBAAUC,OAAOiB,OAAOiC,MAClEG,gBAAgBvC,SAASoC,OAChBI,eAAeG,SAASP,QACzBD,UAAUS,QAAQR,MAAMS,UAAUC,IAAI,UACtCX,UAAUS,QAAQR,MAAMJ,UAAW,MAG3CG,UAAUS,QAAQ5C,SAAQ,CAAC+C,QAASC,SAC5BD,QAAQf,WACRG,UAAUS,QAAQI,OAAS,SAGF,IAA7Bb,UAAUS,QAAQxD,SAClB+C,UAAUc,QAAS"}